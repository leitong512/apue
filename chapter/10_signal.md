# 信号

## 信号的概念

1. 信号是软中断，它提供了一种处理异步事件的方法
    - 产生信号的事件对于进程而言是随机出现的
    - 进程不能简单的测试一个变量来判断是否发生了一个信号，而是必须告诉内核当某个信号发生时，执行哪些操作。
2. 每个信号都有一个名字，这些名字都是以`SIG`开头：
    - 所有的信号名被定义为正整数常量（信号编号），定义在头文件`<signal.h>`中
    - 不存在编号为 0 的信号，`POSIX`将 0 号编号值称作空信号
    - `Mac OS X 10.6.8`以及`Linux 3.2.0`都支持31种信号。
3. 很多条件可以产生信号：
    - 当用户按某些终端键时，引发终端产生的信号。在终端上按`Delete`键（通常`CTRL + C`）产生中断信号（SIGINT）。
    - 硬件异常产生信号：除数为 0 、无效的内存引用等等
        > 这些通常由硬件检查到，并通知内核。然后内核为该条件发生时正在运行的进程产生适当的信号。如对执行一个无效内存引用的进程
        产生`SIGSEGV`信号
    - 进程调用`kill(2)`函数可将任意信号发送给另一个进程或进程组。
        > 要求接受信号的进程和发送信号的进程的所有者必须相同，或者发送信号的进程的所有者是超级用户
    - 用户可以用`kill`命令将信号发送给其他进程。
        > 此命令只是`kill()`函数的接口。通常用于终止一个失控的后台进程
    - 当检测到某种软件条件已经发生并应将其通知有关进程时，也产生信号。如定时器超时的时候产生`SIGALRM`信号
4. 进程可以告诉内核当某个信号发生时，执行下列三种操作之一（我们称作信号处理）：
    - 忽略此信号。大多数信号都可以使用这种方式进程处理，但是`SIGKILL`和`SIGSTOP`信号决不能忽略
        - `SIGKILL`和`SIGSTOP`向内核和超级用户提供了使进程终止或停止的可靠方法
        - 如果忽略某些由硬件异常产生的信号（如非法内存引用或除以0），则进程运行行为未定义的
    - 捕捉信号。为了做到这一点，进程需要通知内核当某种信号发生时，调用一个用户函数。
        - 在用户函数中，内核执行进程希望对这种事件进行的处理
        - 注意无法捕捉`SIGKILL`和`SIGSTOP`信号
    - 执行系统默认动作。对大多数信号的系统默认动作是终止该进程。默认动作是忽略的常见的信号有：
    `SIGCANCEL`（线程库内部使用）、`SIGCHILD`（子进程状态改变）
5. 进程执行时，如果没有显示设定，则所有的信号的处理都为默认动作
    - 调用`fork`之后，子进程继承父进程的信号处理方式，因为子进程在开始时复制了父进程的进程空间
    - 对于子进程，`exec`函数将原来设置要捕捉的信号都改为默认值，非捕捉的信号不变

## 中断的系统调用
    
1. 如果进程在执行一个低速系统调用而阻塞期间捕捉到一个信号，则该系统调用就会被中断而不再继续执行。此时该系统调用
返回出错，其`errno`设置为`EINTR`
    - 这么做的意义是因为一个信号发生了，进程捕捉到了它，意味着已经发生了某种事情，所以是个好机会应当唤醒阻塞的系统调用

2. 为了支持中断的系统调用，我们将系统调用分成两类：低速系统调用和非低速系统调用
    - 低速系统调用是可能使进程永远阻塞的一类系统调用，包括：
        - 如果某些类型文件（如读管道、终端设备、网络设备）的数据不存在，则读操作可能会使调用者永远阻塞
        - 如果写某些类型文件（如写管道、终端设备、网络设备），可能会使得调用者永远阻塞
        - `pause`函数（根据定义，它使调用进程休眠直到捕捉一个信号）和`wait`函数
        - 某些`ioctl`函数
        - 某些进程间通信函数
3. 为了帮助应用程序使其不必处理被中断的系统调用（即不需要人工重新启动被中断的系统调用），`4.2BSD`引进了某些被中断的系统调用
自动重启动
    - 自动重启动的系统调用包括`ioctl`、`read`、`readv`、`write`、`writev`、`wait`、`waitpid`
    - 某些情况下，可能我们并不希望这些函数被中断后重启动，因此`4.3BSD`运行进程基于每个信号禁用重启动功能
    - 需要自动重启动的原因：有时候用户根本不知道所使用的输入，输出设备是否是低速设备。如不提供重启动功能，则对每次`read、
    write`系统调用就要进行是否出错返回的测试；如果是被中断的，则需要再调用`read、write`系统调用
4. `POSIX`要求：只有中断信号的`SA_RESTART`标志有效时，才重启动被该信号中断的系统调用


## 可重入函数

1. 进程捕捉到信号并对其进行处理时，进程正在执行的正常指令序列就被信号处理程序临时中断
    - CPU 首先执行该信号处理程序中的指令
    - 如果从信号处理程序返回，则继续执行进程正在执行的正常指令序列
        > 有可能无法从信号处理程序返回，如在信号处理程序中调用`_exit()`或者`longjmp`
    - 但是有个问题：在信号处理程序中，无法判断捕捉到信号的时候，进程执行到何处。
        - 如果捕捉到信号的时候，进程正在执行`malloc`，那么在信号处理程序中，绝不应该在调用`malloc`。否则或破坏`malloc`维护的
        存储区链表
        - 对于某一类函数，如果在捕捉到信号的时候，进程正在执行这些函数，那么在信号处理程序中，可以安全重复调用这些函数。这类函数
        称作`可重入函数`

2. `SUS`规范说明了在信号处理程序中保证调用安全的函数。这些函数有以下特点：
    - 没有使用静态数据结构。使用了静态数据结构的函数不是可重入的
    - 没有调用`malloc`或者`free`。调用`malloc`或者`free`的函数不是可重入的
    - 没有使用标准`IO`函数。使用标准`IO`函数的函数不是可重入的。因为标准`IO`库很多使用了全局数据结构

3. 当在信号处理函数中调用可重入函数是，应当在调用前保存`errno`，然后在调用后恢复`errno`
    - 因为可重入函数执行失败的时候，可能会修改全局的`errno`值。而这种改变并不属于进程的正常执行逻辑。

